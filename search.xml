<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IP代理池]]></title>
    <url>%2F2019%2F11%2F26%2FIP%E4%BB%A3%E7%90%86%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[简介通过网上的免费代理建立自己的代理池，而要搭建一个代理池，需要四个模块：存储模块、爬取模块、测试模块和接口模块。 存储模块：负责存储爬取下来的代理，使用Redis数据库的SortedSet（有序集合）进行存储，确保代理无重复，并对代理是否可用进行标记。 爬取模块：负责基于提供免费代理的网站进行爬取，代理的形式是IP+端口，爬取下来之后保存到数据库里。 测试模块：负责对代理池中代理的可用性进行测试，设置一个测试URL，然后使用代理去请求，根据响应的状态码判断代理是否可用。 接口模块：提供给爬虫一个接口，返回代理池的接口功能。 下载&amp;安装Redis：下载地址，可直接下载Windows安装文件，安装时选择注册系统服务，简单方便。 Redis Desktop Manager：下载地址 项目：下载地址，解压到指定文件夹。 安装所需依赖包 pip install -r requirements.txt其中，lxml==3.7.2可能无法正常安装，可在requirements.txt将版本信息去除，安装最新的lxml。 如有git工具，亦可通过以下代码获取： git clone git@github.com:jhao104/proxy_pool.git注：推荐使用virtualenv工具建立独立项目空间。 配置&amp;启动配置Config/setting.py: 1234567891011121314151617181920212223242526272829303132# Config/setting.py 为项目配置文件# 配置DB DATABASES = &#123; &quot;default&quot;: &#123; &quot;TYPE&quot;: &quot;REDIS&quot;, &quot;HOST&quot;: &quot;127.0.0.1&quot;, &quot;PORT&quot;: 6379, &quot;NAME&quot;: &quot;proxy&quot;, &quot;PASSWORD&quot;: &quot;&quot; &#125;&#125;# 配置 ProxyGetterPROXY_GETTER = [ &quot;freeProxy01&quot;, # 这里是启用的代理抓取函数名，可在ProxyGetter/getFreeProxy.py 扩展 &quot;freeProxy02&quot;, ....]# 配置 API服务SERVER_API = &#123; &quot;HOST&quot;: &quot;0.0.0.0&quot;, # 监听ip, 0.0.0.0 监听所有IP &quot;PORT&quot;: 5010 # 监听端口&#125; # 上面配置启动后，代理池访问地址为 http://127.0.0.1:5010 启动程序分为schedule调度程序和webserverApi服务 首先启动调度程序 python proxyPool.py schedule然后启动webApi服务 python proxyPool.py webserver启动过几分钟后即可看到抓取到的代理IP，可直接到数据库中查看，也可以通过api访问http://127.0.0.1:5010 查看。 Web Api api method Description arg / GET api介绍 None /get GET 随机获取一个代理 None /get_all GET 获取所有代理 None /get_status GET 查看代理数量 None /delete GET 删除代理 None 扩展项目默认包含几个免费的代理获取方法，亦可通过以下方式扩展新的代理： 首先在GetFreeProxy类中添加获取代理的静态方法，需要以生成器(yield)形式返回host:ip格式的代理，例如: 12345678910111213class GetFreeProxy(object): # .... # 你自己的方法 @staticmethod def freeProxyCustom(): # 命名不和已有重复即可 # 通过某网站或者某接口或某数据库获取代理 任意你喜欢的姿势都行 # 假设你拿到了一个代理列表 proxies = [&quot;139.129.166.68:3128&quot;, &quot;139.129.166.61:3128&quot;, ...] for proxy in proxies: yield proxy # 确保每个proxy都是 host:ip正确的格式就行 添加好方法后，修改Config/setting.py文件中的PROXY_GETTER项，在PROXY_GETTER下添加自定义的方法的名字: 123456PROXY_GETTER = [ &quot;freeProxy01&quot;, &quot;freeProxy02&quot;, .... &quot;freeProxyCustom&quot; # # 确保名字和你添加方法名字一致] ProxySchedule会每隔一段时间抓取一次代理，下次抓取时会自动识别调用你定义的方法。 可用代理列表目前实现的采集免费代理网站有 厂商名称 状态 更新速度 可用率 是否被墙 地址 无忧代理 可用 几分钟一次 * 否 地址 66代理 可用 更新很慢 * 否 地址 西刺代理 可用 几分钟一次 * 否 地址 全网代理 可用 几分钟一次 * 否 地址 快代理 可用 几分钟一次 * 否 地址 云代理 可用 几分钟一次 * 否 地址 IP海 可用 几小时一次 * 否 地址 免费IP代理库 可用 快 * 否 地址 注：已去除无免费和被墙的代理网站。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>proxy pool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wagtail-3 - 示例网站]]></title>
    <url>%2F2019%2F11%2F18%2Fwagtail-3%20-%20%E7%A4%BA%E4%BE%8B%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[简介在Wagtail中，可以通过命令wagtail start创建一个初始的网站，开始定制个性化的网站。 同时，Wagtail提供了一个示例网站The Wagtail Bakery，其包含了示例页面和模板，初步了解Wagtail时，建议使用此示例网站作为起点。 示例网站的下载和使用、配置文档见github bakerydemo。 此示例网站提供Wagtail CMS开发常用的特性和接口，并为开发CMS系统的管理编辑接口提供一定的帮助。其代码可无限制的应用于任何地方，但不建议使用此示例网站来开始搭建你的网站，它只是用来帮助了解和熟悉Wagtail的。 安装建议使用Virtualenv安装示例网站，前置环境要求如下 Python 3.4, 3.5, 3.6 or above Virtualenv VirtualenvWrapper (optional)首先创建单独的项目空间 virtualenv bakerydemo在\bakerydemo\Scripts文件夹下使用activate命令激活虚拟空间，返回虚拟根目录，创建单独的项目文件夹并clone代码 git clone https://github.com/wagtail/bakerydemo.git亦可直接通过github项目页面下载项目压缩包。 安装项目依赖 pip install -r requirements/base.txt创建数据库并导入初始数据 ./manage.py migrate ./manage.py load_initial_data ./manage.py runserver其它方式安装可参考by vagrant和by docker。]]></content>
      <categories>
        <category>wagtail系列</category>
      </categories>
      <tags>
        <tag>wagtail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wagtail-2 - 第一个网站]]></title>
    <url>%2F2019%2F11%2F07%2Fwagtail-2%20-%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[修改后台编辑窗口初始后台管理页面中，页面内容仅包括标题项，可通过以下方式添加其他元素。 新增正文编辑框，可编辑 home/models.py : 12345678910111213from django.db import modelsfrom wagtail.core.models import Pagefrom wagtail.core.fields import RichTextFieldfrom wagtail.admin.edit_handlers import FieldPanelclass HomePage(Page): body = RichTextField(blank=True) content_panels = Page.content_panels + [ FieldPanel(&apos;body&apos;, classname=&quot;full&quot;), ] 其中，body为一个富文本窗口（特殊wagtail元素），content_panels定义页面容器。 然后运行 python manage.py makemigrations python manage.py migrate 更新数据库。 每次修改代码之后，都需要运行上述代码，以确保功能更新。 现在，通过后台管理页面-&gt;Homepage-&gt;Edit，即可看到新的body页面，编辑正文内容，然后发布此页面。 修改前台展示页面发布之后，返回前台首页，发现仅网页标题改了，其他一切未变，这是因为首页的渲染模板是未变。 编辑 home/templates/home/home_page.html ，使其仅包含以下内容 123456789&#123;% extends &quot;base.html&quot; %&#125;&#123;% load wagtailcore_tags %&#125;&#123;% block body_class %&#125;template-homepage&#123;% endblock %&#125;&#123;% block content %&#125; &#123;&#123; page.body|richtext &#125;&#125;&#123;% endblock %&#125; 再次刷新首页，即可看到已显示编辑内容，但界面好丑…. Wagtail提供很多模板标签，可通过在模板文件头部添加 load wagtailcore_tags 显式引入模板标签。 本文中，使用富文本框来编辑和输出正文内容: 12&#123;% load wagtailcore_tags %&#125;&#123;&#123; page.body|richtext &#125;&#125; 最终在前台页面，会将其渲染为: 12345&lt;div class=&quot;rich-text&quot;&gt; &lt;p&gt; &lt;b&gt;Welcome&lt;/b&gt; to our new site! &lt;/p&gt;&lt;/div&gt; 注: 需要在每一个模板文件中包含 load wagtailcore_tags 来使用Wagtail标签，否则Django将抛出错误TemplateSyntaxError。 简单博客网站在wagtail项目根目录下，通过以下代码，在已有wagtail网站中添加一个blog应用： python manage.py startapp blog编辑 mysite/settings/base.py ，在 INSTALLED_APPS 添加 blog 博客首页通过编辑blog/models.py，定义一个简单的博客首页: 1234567891011from wagtail.core.models import Pagefrom wagtail.core.fields import RichTextFieldfrom wagtail.admin.edit_handlers import FieldPanelclass BlogIndexPage(Page): intro = RichTextField(blank=True) content_panels = Page.content_panels + [ FieldPanel(&apos;intro&apos;, classname=&quot;full&quot;) ] 运行以下代码，确保更新 python manage.py makemigrations python manage.py migrate 模板文件名为BlogIndexPage，默认的模板文件位于根目录下/mysite/templates/blog/blog_index_page.html。创建此文件，并包含以下内容： 123456789101112131415161718&#123;% extends &quot;base.html&quot; %&#125;&#123;% load wagtailcore_tags %&#125;&#123;% block body_class %&#125;template-blogindexpage&#123;% endblock %&#125;&#123;% block content %&#125; &lt;h1&gt;&#123;&#123; page.title &#125;&#125;&lt;/h1&gt; &lt;div class=&quot;intro&quot;&gt;&#123;&#123; page.intro|richtext &#125;&#125;&lt;/div&gt; &#123;% for post in page.get_children %&#125; &lt;h2&gt;&lt;a href=&quot;&#123;% pageurl post %&#125;&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;&lt;/h2&gt; &#123;&#123; post.specific.intro &#125;&#125; &#123;&#123; post.specific.body|richtext &#125;&#125; &#123;% endfor %&#125;&#123;% endblock %&#125; 在wagtail后台管理界面，创建BlogIndexPage作为Homepage的子页面，确保Promote页签中slug为blog并发布。 现在，可以通过 http://localhost:8000/blog/ 访问你的blog网站。 发布文章页面编辑 blog/models.py: 1234567891011121314151617181920212223242526from django.db import modelsfrom wagtail.core.models import Pagefrom wagtail.core.fields import RichTextFieldfrom wagtail.admin.edit_handlers import FieldPanelfrom wagtail.search import index# Keep the definition of BlogIndexPage, and add:class BlogPage(Page): date = models.DateField(&quot;Post date&quot;) intro = models.CharField(max_length=250) body = RichTextField(blank=True) search_fields = Page.search_fields + [ index.SearchField(&apos;intro&apos;), index.SearchField(&apos;body&apos;), ] content_panels = Page.content_panels + [ FieldPanel(&apos;date&apos;), FieldPanel(&apos;intro&apos;), FieldPanel(&apos;body&apos;, classname=&quot;full&quot;), ] 运行以下代码，确保更新 python manage.py makemigrations python manage.py migrate 创建模板文件 mysite/templates/blog/blog_page.html: 1234567891011121314151617&#123;% extends &quot;base.html&quot; %&#125;&#123;% load wagtailcore_tags %&#125;&#123;% block body_class %&#125;template-blogpage&#123;% endblock %&#125;&#123;% block content %&#125; &lt;h1&gt;&#123;&#123; page.title &#125;&#125;&lt;/h1&gt; &lt;p class=&quot;meta&quot;&gt;&#123;&#123; page.date &#125;&#125;&lt;/p&gt; &lt;div class=&quot;intro&quot;&gt;&#123;&#123; page.intro &#125;&#125;&lt;/div&gt; &#123;&#123; page.body|richtext &#125;&#125; &lt;p&gt;&lt;a href=&quot;&#123;&#123; page.get_parent.url &#125;&#125;&quot;&gt;Return to blog&lt;/a&gt;&lt;/p&gt;&#123;% endblock %&#125; 可以发布几个博客内容页面，作为博客首页（BlogIndexPage）的子页面，确保创建时选择“Blog Page”类型。 一个较为简陋的博客系统初步搞定。 排序和发布但是，现在博客首页现在还有一些问题： 文章按照时间顺序显示，先发布先显示 文章无论是否发布，都显示 变更首页文章排序方式，可通过修改blog/models.py，重写BlogIndexPage的get_context()： 123456789class BlogIndexPage(Page): intro = RichTextField(blank=True) def get_context(self, request): # Update context to include only published posts, ordered by reverse-chron context = super().get_context(request) blogpages = self.get_children().live().order_by(&apos;-first_published_at&apos;) context[&apos;blogpages&apos;] = blogpages return context 修改模板blog_index_page.html，将 ‘for post in page.get_children’ 修改为 ‘for post in blogpages’ 现在，试着将一片文章取消发布，即可发现它不再显示在博客首页了。同时，显示顺序也变更为时间倒序。 图片支持尽管通过富文本框新增图片很容易，但仍然建议将图片作为一个新元素存入数据库，这样的话此图片可独立于当前文章，用在网站任何地方。 在blog/models.py新增BlogPageGalleryImage： 12345678910111213141516171819202122232425262728293031323334353637383940414243from django.db import models# New imports added for ParentalKey, Orderable, InlinePanel, ImageChooserPanelfrom modelcluster.fields import ParentalKeyfrom wagtail.core.models import Page, Orderablefrom wagtail.core.fields import RichTextFieldfrom wagtail.admin.edit_handlers import FieldPanel, InlinePanelfrom wagtail.images.edit_handlers import ImageChooserPanelfrom wagtail.search import index# ... (Keep the definition of BlogIndexPage, and update BlogPage:)class BlogPage(Page): date = models.DateField(&quot;Post date&quot;) intro = models.CharField(max_length=250) body = RichTextField(blank=True) search_fields = Page.search_fields + [ index.SearchField(&apos;intro&apos;), index.SearchField(&apos;body&apos;), ] content_panels = Page.content_panels + [ FieldPanel(&apos;date&apos;), FieldPanel(&apos;intro&apos;), FieldPanel(&apos;body&apos;, classname=&quot;full&quot;), InlinePanel(&apos;gallery_images&apos;, label=&quot;Gallery images&quot;), ]class BlogPageGalleryImage(Orderable): page = ParentalKey(BlogPage, on_delete=models.CASCADE, related_name=&apos;gallery_images&apos;) image = models.ForeignKey( &apos;wagtailimages.Image&apos;, on_delete=models.CASCADE, related_name=&apos;+&apos; ) caption = models.CharField(blank=True, max_length=250) panels = [ ImageChooserPanel(&apos;image&apos;), FieldPanel(&apos;caption&apos;), ] 运行以下代码，确保更新 python manage.py makemigrations python manage.py migrate 通过以上步骤，在新增博客文章页面BlogPage增加了一个图片选项。 修正mysite/templates/blog/blog_page.html，使文章显示页面能够显示图片： 123456789101112131415161718192021222324&#123;% extends &quot;base.html&quot; %&#125;&#123;% load wagtailcore_tags wagtailimages_tags %&#125;&#123;% block body_class %&#125;template-blogpage&#123;% endblock %&#125;&#123;% block content %&#125; &lt;h1&gt;&#123;&#123; page.title &#125;&#125;&lt;/h1&gt; &lt;p class=&quot;meta&quot;&gt;&#123;&#123; page.date &#125;&#125;&lt;/p&gt; &lt;div class=&quot;intro&quot;&gt;&#123;&#123; page.intro &#125;&#125;&lt;/div&gt; &#123;&#123; page.body|richtext &#125;&#125; &#123;% for item in page.gallery_images.all %&#125; &lt;div style=&quot;float: left; margin: 10px&quot;&gt; &#123;% image item.image fill-320x240 %&#125; &lt;p&gt;&#123;&#123; item.caption &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;p&gt;&lt;a href=&quot;&#123;&#123; page.get_parent.url &#125;&#125;&quot;&gt;Return to blog&lt;/a&gt;&lt;/p&gt;&#123;% endblock %&#125; 通过在blog/models.py的BlogPage中定义main_image，返回文章中首个图片: 1234567891011121314151617181920212223class BlogPage(Page): date = models.DateField(&quot;Post date&quot;) intro = models.CharField(max_length=250) body = RichTextField(blank=True) def main_image(self): gallery_item = self.gallery_images.first() if gallery_item: return gallery_item.image else: return None search_fields = Page.search_fields + [ index.SearchField(&apos;intro&apos;), index.SearchField(&apos;body&apos;), ] content_panels = Page.content_panels + [ FieldPanel(&apos;date&apos;), FieldPanel(&apos;intro&apos;), FieldPanel(&apos;body&apos;, classname=&quot;full&quot;), InlinePanel(&apos;gallery_images&apos;, label=&quot;Gallery images&quot;), ] 更新 blog_index_page.html ，使博客首页包含图片（首张）的显示： 12345678910111213141516&#123;% load wagtailcore_tags wagtailimages_tags %&#125;...&#123;% for post in blogpages %&#125; &#123;% with post=post.specific %&#125; &lt;h2&gt;&lt;a href=&quot;&#123;% pageurl post %&#125;&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;&lt;/h2&gt; &#123;% with post.main_image as main_image %&#125; &#123;% if main_image %&#125;&#123;% image main_image fill-160x100 %&#125;&#123;% endif %&#125; &#123;% endwith %&#125; &lt;p&gt;&#123;&#123; post.intro &#125;&#125;&lt;/p&gt; &#123;&#123; post.body|richtext &#125;&#125; &#123;% endwith %&#125;&#123;% endfor %&#125; 标签&amp;分类待后整理添加标签首先，修改 blog/models.py： 12345678910111213141516171819202122232425262728293031323334353637383940414243from django.db import models# New imports added for ClusterTaggableManager, TaggedItemBase, MultiFieldPanelfrom modelcluster.fields import ParentalKeyfrom modelcluster.contrib.taggit import ClusterTaggableManagerfrom taggit.models import TaggedItemBasefrom wagtail.core.models import Page, Orderablefrom wagtail.core.fields import RichTextFieldfrom wagtail.admin.edit_handlers import FieldPanel, InlinePanel, MultiFieldPanelfrom wagtail.images.edit_handlers import ImageChooserPanelfrom wagtail.search import index# ... (Keep the definition of BlogIndexPage)class BlogPageTag(TaggedItemBase): content_object = ParentalKey( &apos;BlogPage&apos;, related_name=&apos;tagged_items&apos;, on_delete=models.CASCADE )class BlogPage(Page): date = models.DateField(&quot;Post date&quot;) intro = models.CharField(max_length=250) body = RichTextField(blank=True) tags = ClusterTaggableManager(through=BlogPageTag, blank=True) # ... (Keep the main_image method and search_fields definition) content_panels = Page.content_panels + [ MultiFieldPanel([ FieldPanel(&apos;date&apos;), FieldPanel(&apos;tags&apos;), ], heading=&quot;Blog information&quot;), FieldPanel(&apos;intro&apos;), FieldPanel(&apos;body&apos;), InlinePanel(&apos;gallery_images&apos;, label=&quot;Gallery images&quot;), ] 运行以下代码，确保更新 python manage.py makemigrations python manage.py migrate Note the new modelcluster and taggit imports, the addition of a new BlogPageTag model, and the addition of a tags field on BlogPage. We’ve also taken the opportunity to use a MultiFieldPanel in content_panels to group the date and tags fields together for readability. Edit one of your BlogPage instances, and you should now be able to tag posts: Tagging a postTo render tags on a BlogPage, add this to blog_page.html: 12345678&#123;% if page.tags.all.count %&#125; &lt;div class=&quot;tags&quot;&gt; &lt;h3&gt;Tags&lt;/h3&gt; &#123;% for tag in page.tags.all %&#125; &lt;a href=&quot;&#123;% slugurl &apos;tags&apos; %&#125;?tag=&#123;&#123; tag &#125;&#125;&quot;&gt;&lt;button type=&quot;button&quot;&gt;&#123;&#123; tag &#125;&#125;&lt;/button&gt;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt;&#123;% endif %&#125; Notice that we’re linking to pages here with the builtin slugurl tag rather than pageurl, which we used earlier. The difference is that slugurl takes a Page slug (from the Promote tab) as an argument. pageurl is more commonly used because it is unambiguous and avoids extra database lookups. But in the case of this loop, the Page object isn’t readily available, so we fall back on the less-preferred slugurl tag. Visiting a blog post with tags should now show a set of linked buttons at the bottom - one for each tag. However, clicking a button will get you a 404, since we haven’t yet defined a “tags” view. Add to models.py: 123456789101112class BlogTagIndexPage(Page): def get_context(self, request): # Filter by tag tag = request.GET.get(&apos;tag&apos;) blogpages = BlogPage.objects.filter(tags__name=tag) # Update template context context = super().get_context(request) context[&apos;blogpages&apos;] = blogpages return context Note that this Page-based model defines no fields of its own. Even without fields, subclassing Page makes it a part of the Wagtail ecosystem, so that you can give it a title and URL in the admin, and so that you can manipulate its contents by returning a QuerySet from its get_context() method. Migrate this in, then create a new BlogTagIndexPage in the admin. You’ll probably want to create the new page/view as a child of Homepage, parallel to your Blog index. Give it the slug “tags” on the Promote tab. Access /tags and Django will tell you what you probably already knew: you need to create a template blog/blog_tag_index_page.html: 123456789101112131415161718192021222324&#123;% extends &quot;base.html&quot; %&#125;&#123;% load wagtailcore_tags %&#125;&#123;% block content %&#125; &#123;% if request.GET.tag|length %&#125; &lt;h4&gt;Showing pages tagged &quot;&#123;&#123; request.GET.tag &#125;&#125;&quot;&lt;/h4&gt; &#123;% endif %&#125; &#123;% for blogpage in blogpages %&#125; &lt;p&gt; &lt;strong&gt;&lt;a href=&quot;&#123;% pageurl blogpage %&#125;&quot;&gt;&#123;&#123; blogpage.title &#125;&#125;&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt; &lt;small&gt;Revised: &#123;&#123; blogpage.latest_revision_created_at &#125;&#125;&lt;/small&gt;&lt;br /&gt; &#123;% if blogpage.author %&#125; &lt;p&gt;By &#123;&#123; blogpage.author.profile &#125;&#125;&lt;/p&gt; &#123;% endif %&#125; &lt;/p&gt; &#123;% empty %&#125; No pages found with that tag. &#123;% endfor %&#125;&#123;% endblock %&#125; We’re calling the built-in latest_revision_created_at field on the Page model - handy to know this is always available. We haven’t yet added an “author” field to our BlogPage model, nor do we have a Profile model for authors - we’ll leave those as an exercise for the reader. Clicking the tag button at the bottom of a BlogPost should now render a page something like this: A simple tag view 添加分类Let’s add a category system to our blog. Unlike tags, where a page author can bring a tag into existence simply by using it on a page, our categories will be a fixed list, managed by the site owner through a separate area of the admin interface. First, we define a BlogCategory model. A category is not a page in its own right, and so we define it as a standard Django models.Model rather than inheriting from Page. Wagtail introduces the concept of “snippets” for reusable pieces of content that need to be managed through the admin interface, but do not exist as part of the page tree themselves; a model can be registered as a snippet by adding the @register_snippet decorator. All the field types we’ve used so far on pages can be used on snippets too - here we’ll give each category an icon image as well as a name. Add to blog/models.py: 123456789101112131415161718192021from wagtail.snippets.models import register_snippet@register_snippetclass BlogCategory(models.Model): name = models.CharField(max_length=255) icon = models.ForeignKey( &apos;wagtailimages.Image&apos;, null=True, blank=True, on_delete=models.SET_NULL, related_name=&apos;+&apos; ) panels = [ FieldPanel(&apos;name&apos;), ImageChooserPanel(&apos;icon&apos;), ] def __str__(self): return self.name class Meta: verbose_name_plural = &apos;blog categories&apos; Note Note that we are using panels rather than content_panels here - since snippets generally have no need for fields such as slug or publish date, the editing interface for them is not split into separate ‘content’ / ‘promote’ / ‘settings’ tabs as standard, and so there is no need to distinguish between ‘content panels’ and ‘promote panels’. Migrate this change in, and create a few categories through the Snippets area which now appears in the admin menu. We can now add categories to the BlogPage model, as a many-to-many field. The field type we use for this is ParentalManyToManyField - this is a variant of the standard Django ManyToManyField which ensures that the chosen objects are correctly stored against the page record in the revision history, in much the same way that ParentalKey replaces ForeignKey for one-to-many relations. 1234567891011121314151617181920212223242526272829# New imports added for forms and ParentalManyToManyFieldfrom django import formsfrom django.db import modelsfrom modelcluster.fields import ParentalKey, ParentalManyToManyFieldfrom modelcluster.contrib.taggit import ClusterTaggableManagerfrom taggit.models import TaggedItemBase# ...class BlogPage(Page): date = models.DateField(&quot;Post date&quot;) intro = models.CharField(max_length=250) body = RichTextField(blank=True) tags = ClusterTaggableManager(through=BlogPageTag, blank=True) categories = ParentalManyToManyField(&apos;blog.BlogCategory&apos;, blank=True) # ... (Keep the main_image method and search_fields definition) content_panels = Page.content_panels + [ MultiFieldPanel([ FieldPanel(&apos;date&apos;), FieldPanel(&apos;tags&apos;), FieldPanel(&apos;categories&apos;, widget=forms.CheckboxSelectMultiple), ], heading=&quot;Blog information&quot;), FieldPanel(&apos;intro&apos;), FieldPanel(&apos;body&apos;), InlinePanel(&apos;gallery_images&apos;, label=&quot;Gallery images&quot;), ] Here we’re making use of the widget keyword argument on the FieldPanel definition to specify a checkbox-based widget instead of the default multiple select box, as this is often considered more user-friendly. Finally, we can update the blog_page.html template to display the categories: 12345678910111213141516&lt;h1&gt;&#123;&#123; page.title &#125;&#125;&lt;/h1&gt;&lt;p class=&quot;meta&quot;&gt;&#123;&#123; page.date &#125;&#125;&lt;/p&gt;&#123;% with categories=page.categories.all %&#125; &#123;% if categories %&#125; &lt;h3&gt;Posted in:&lt;/h3&gt; &lt;ul&gt; &#123;% for category in categories %&#125; &lt;li style=&quot;display: inline&quot;&gt; &#123;% image category.icon fill-32x32 style=&quot;vertical-align: middle&quot; %&#125; &#123;&#123; category.name &#125;&#125; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &#123;% endif %&#125;&#123;% endwith %&#125;]]></content>
      <categories>
        <category>wagtail系列</category>
      </categories>
      <tags>
        <tag>wagtail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[virtualenv基本使用]]></title>
    <url>%2F2019%2F11%2F06%2Fvirtualenv%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介建立一个专属于项目的虚拟python环境，实际应用中可用virtualenv来保持一个干净的互不干扰的运行环境。 场景： 如果要同时开发多个应用程序，那这些应用程序都会共用一个Python环境，但如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境，virtualenv应运而生。 安装pip install virtualenv 测试是否安装成功： virtualenv --version简单使用1.创建虚拟环境 virtualenv -p c:\Python36\python.exe venv说明： -p是指定python的版本（需要带上路径）(可选)，venv就是虚拟的环境变量（目录名字）。 如不需要指定python版本，直接使用命令： virtualenv venv将使用系统默认python版本。 2.激活虚拟环境 需进入venv文件夹的script目录，执行activate命令 activate此刻起，将使用venv虚拟环境，pip安装的包也会将会放在venv文件夹中，与全局安装的Python隔绝开。 3.退出虚拟环境 使用deactivate命令即可退出当前虚拟环境 deactivate4.删除虚拟环境 只需删除对应的文件夹即可。 附注可用pip freeze查看当前安装各个包的版本信息 pip freeze同时，可使用： pip freeze &gt; requirements.txt创建一个requirements.txt文件，包含当前环境中所有包及其版本的列表。 可使用此文件帮助其他其他开发者重新创建一致的环境，以便以后安装相同版本的包环境。 pip install -r requirements.txt确保安装、部署和开发者之间的一致性。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wagtail-1 - 背景及初始配置]]></title>
    <url>%2F2019%2F11%2F06%2Fwagtail-1%20-%20%E8%83%8C%E6%99%AF%E5%8F%8A%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介wagtail是基于django开发的cms系统，提供了一个用户管理中心和快速吸引人的界面，让编辑可以直观地创建和结构化内容。 安装pip install wagtail wagtail start mysite cd mysite python manage.py migrate python manage.py createsuperuser python manage.py runserver 初始功能访问 http://127.0.0.1:8000 即可看到wagtail首页。 注：当前首页仅为示意，后续需配置网站主题。 可通过首页右下角链接或 http://127.0.0.1:8000/admin ，输入正确的用户名密码，即可访问后台管理页面。 可通过后台管理页面操作页面的增删改查、用户的设置等相关操作。]]></content>
      <categories>
        <category>wagtail系列</category>
      </categories>
      <tags>
        <tag>wagtail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Teadocs 使用初步]]></title>
    <url>%2F2019%2F09%2F11%2FTeadocs%E5%88%9D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[简介Teadocs是一款能够帮你快速构建html文档的工具，基于nodejs，使用markdown编写文档内容，提供内置的搜索技术。Teadocs基于markdown文档自动生成html文档，可复用、可移植，可以任意部署。 可用来编写开源书籍、API文档学习、笔记、学习心得等结构化文档，简洁高效。 安装需要nodejs&gt;=8.0，npm版本&gt;3，建议安装到全局，可随时通过shell调用。 $ npm install -g teadocs 初始使用初始化一个文档项目 $ teadcos init mydocs进入这个文档目录 $ cd mydocs自动生成项目初始结构，可在编写好tree.md（菜单的配置文件）的情况下，运行以下命令，teadocs可以自动生成md文件。 $ teadocs initmd文档完成后，可执行下面命令编译成html $ teadocs build更推荐使用开发模式进行文档编写，进入文档编辑模式后，将监视markdown文件的变化，实时热替换html页面。 $ teadocs dev菜单配置文件说明左侧菜单的配置文件是文档根目录下面的tree.md文件，它使用markdown语法。 以初始项目为例，菜单结构如下： 介绍 快速入门 安装 +配置介绍 文档目录结构介绍 主配置文件说明 菜单配置文件说明 markdown模版 自定义主题 部署 语法完全使用markdown里的无序列表定义语法，要注意以下几点： [] 里的内容表示菜单的标题，如果不写[]则代表这个菜单没有链接仅作为一个菜单名称。 () 里的内容表示菜单的markdown文件的地址，并且也代表了生成后的html文件url。 +代表了在生成的html里默认展开这个菜单，需要注意的是，这不是markdown的语法，这是teadocs的规定，+一定要写在文本的前面，而不是[的前面。 markdown模版markdown文件可以使用内置的ejs模版引擎，比如我们可以写个循环： &lt; % [1,2,3,4].forEach(function () { % &gt; - 欢迎使用Teadocs文档生成工具 &lt; % }) % &gt;效果： 欢迎使用Teadocs文档生成工具 欢迎使用Teadocs文档生成工具 欢迎使用Teadocs文档生成工具 欢迎使用Teadocs文档生成工具 代码上传目前不支持一键上传同步，可通过将根目录下/build文件夹整体上传到github.io文件夹即可，建议使用github desktop工具同步即可。 github.io项目创建使用见前文。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Teadocs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 语法初步]]></title>
    <url>%2F2019%2F08%2F07%2Fmarkdown%E8%AF%AD%E6%B3%95%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[标题# 一级标题，一般一级标题下自带分割线 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题列表有序列表-序号可随便填写，并不影响最终序列 标题1 标题2 标题3 无序列表 标题1 标题2 标题3 引用 我是引用文本1 我是嵌套的引用文本1我是嵌套的引用文本2 在嵌套一层1 在嵌套一层2 我是嵌套的引用文本3 我是引用文本2 文字的样式加粗倾斜删除线下划线 markdown原生并不支持下划线，可通过html标签实现 链接与图片baidu 表格默认的对齐方式为：左对齐方式。 列名1 列名2 列名3 列名4 值1 值1 值2 值x 值1 值1 值2 值x 值1 值1 值2 值x 关键字、代码块、换行、分割线关键字 1代码块 sdfsdfs 换行可插入一个空行，也可在本行末尾插入两个空格任意连续三个--- +++均可实现分割线]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 使用初步]]></title>
    <url>%2F2019%2F08%2F07%2Fhexo%E5%88%9D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[安装npm install -g hexo项目初始化选择新建项目所在文件夹，执行以下命令 hexo init myhexo #初始化项目文档 cd myhexo npm install #安装依赖 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） 主题变更将目标主题clone到/themes文件夹下 yilia $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia modernist $ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist jacman $ git clone https://github.com/cnfeat/cnfeat.git themes/jacman next $ git clone https://github.com/theme-next/hexo-theme-next 修改配置参照以下，综合添加评论的复杂度，推荐next+valine。 项目配置修改配置文件_config.yml # Site title: 鱼之乐 subtitle: 子非鱼安知鱼之乐 description: keywords: author: 鱼之乐 language: timezone: ...... # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next #指定使用的主题，主题放在/themes文件夹下 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/hmilywb/hmilywb.github.io branch: master代码上传必要条件： 配置SSH KEY，相当于用户名密码 配置_config.yml中有关deploy的部分，已在上文项目配置搞定 安装插件hexo-deployer-git npm install hexo-deployer-git –save 正常代码上传可通过 hexo d 注： 此时可能会报错，显示 Fatal: HttpRequestException encountered.这是因为Github禁用了TLS v1.0 and v1.1这种弱加密标准，需要手动更新Windows的git凭证管理器，可从Github官方下载较新版本安装即可。 hexo 常用命令&amp;简写hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本缩写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy组合命令： hexo s -g #生成并本地预览 hexo d -g #生成并上传写博客定位到hexo根目录，执行命令： hexo new &apos;my-first-page&apos;自动在_posts下生成相关md文件my-first-page.md 这个命令的好处是帮我们自动生成了默认内容，打开这个文件即可开始写博客了，默认生成如下内容： title: postName #文章页面上的显示名称，一般是中文 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改 categories: 默认分类 #分类 tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面菜单设置菜单包括：首页、归档、分类、标签、关于等等，默认的只有首页和归档两个，可打开主题配置文件找到Menu Settings menu: home: / || home //首页 archives: /archives/ || archive //归档 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404以archives: /archives/ || archive为例：|| 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome。 创建新的菜单页面，注意在next主题的配置文件中，categories/tags/about是关键词 hexo new page categories # or tags/about修改/source/文件夹下index.md文件，以categories为例 --- title: categories date: 2018-03-02 12:33:16 type: &quot;categories&quot; ---## Next主题样式设置 Next主题有4种风格可供选择，打开主题配置文件找到Scheme Settings # Schemes # scheme: Muse # scheme: Mist # scheme: Pisces scheme: Gemini4种风格大同小异，目前使用的是Gemini风格。 添加搜索功能安装hexo-generator-searchdb插件 npm install hexo-generator-searchdb --save打开站点配置文件找到Extensions，在下面添加 # 搜索 search: path: search.xml field: post format: html limit: 10000打开主题配置文件找到Local search，将enable设置为true 添加评论功能推荐使用valine，首先注册valine 国际版 创建一个开发版应用（免费） 在LeanCloud-设置-安全中心，把除数据存储其他选项都关闭，安全域名中添加域名 在LeanCloud-存储，添加两个class，分别为Comment和Counter，无限制 在LeanCloud-设置-应用key，获取appid和appkey，以备后用 打开主题配置文件（即next主题中的_config.yml）,找到valine的配置 valine: enable: true appid: xxxxx # Your leancloud application appid appkey: xxxxx # Your leancloud application appkeyhexo重新generate和server，最好clean一下。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github配置]]></title>
    <url>%2F2019%2F08%2F06%2Fgithub%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Github简介 Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。 GitHub可以托管各种git库的站点。 GitHub Pages免费的静态站点，三个特点：免费托管、自带主题、支持自制页面和Jekyll。 为什么使用Github Pages 搭建简单而且免费； 支持静态脚本； 可以绑定你的域名； DIY自由发挥，动手实践一些有意思的东西； 理想写博环境，git+github+markdown+jekyll； Github初入 注册自不必说：github官网,按照提示注册即可 创建Repository：登录之后，点击右上角Create New Repository创建一个Repository name为username.github.io的项目 Repository配置： 点击进入新建Repository页面，点击右侧Settings进入配置页面 点击Github Pages容器中的Source按钮，选择master分支 选择喜欢的themes，即完成了github page的初始配置 Github同步工具推荐使用github desktop，也可使用SVN和git，部分包自带更新模块（调用git） 配置SSH keyGit提交代码需要有github权限，不推荐使用用户名和密码，一般使用ssh key来与github进行身份验证。 ssh ls #检查本机已存在的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。 ssh-keygen -t rsa -C &quot;邮件地址&quot;然后连续3次回车选择默认选项，生成一个文件在用户目录下，打开用户目录，找到id_rsa.pub文件，复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key添加进去即可 测试一下是否配置成功: ssh -T git@github.com设置账号信息: git config --global user.name &quot;你的名字&quot; git config --global user.email &quot;邮箱@邮箱.com&quot; #github邮箱]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见问题汇总]]></title>
    <url>%2F1983%2F11%2F11%2FFAQ%2F</url>
    <content type="text"><![CDATA[此篇记录一些常见问题，随遇随补 PowerShell“无法加载文件ps1，因为在此系统中禁止执行脚本。有关详细信息，请参阅 “get-help about_signing” 这是因为没有权限执行脚本。执行 set-executionpolicy remotesigned即可解决。]]></content>
      <categories>
        <category>FAQ</category>
      </categories>
      <tags>
        <tag>FAQ</tag>
      </tags>
  </entry>
</search>
